package com.controller.generators;

import com.controller.subgenerators.ISubGenerator;
import com.model.Template;
import lombok.Getter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

/**
 Main generator that,using the instances of the sub generators,the patterns mapped to them and the formatter,combines the values generated by each generator and
 returns a stream of values that conform to the input given by the user
 */
@Getter
public class MainGenerator implements IGenerator {
    private final Template template;
    private final Map<Integer, ISubGenerator> iSubGenerators;
    private final Map<Integer,String> values ;

    /**
     * @param template      contains all the patterns and the formatter
     * @param iSubGenerators instances of all sub generators that will be used
     */
    public MainGenerator(Template template, Map<Integer, ISubGenerator> iSubGenerators) {
        this.template = template;
        this.iSubGenerators = iSubGenerators;
        this.values = new HashMap<Integer, String>() {};
        this.initValuesMap();
    }

    /**
     * @return A stream of generated values.
     */
    public Stream<String> generate() {

        return Stream.generate(this::generateNextValue);
    }

    /**
     * iterates through all the generated values and formats them together by using the formatter
     *
     * @return resulted value
     */
    private String generateNextValue() {

        Boolean successful = false;
        int ctr = 0 ;
        do{
            successful = this.iterate();
            ctr++;
        }while(Boolean.TRUE.equals(!successful) && ctr < 1000);

        if (Boolean.TRUE.equals(successful)) {
            List<String> formattedValues = new ArrayList<>();
            for (Map.Entry<Integer, String> entry : this.values.entrySet()) {
                String value = entry.getValue();
                formattedValues.add(value);
            }
            //now format all at once
            return this.format(formattedValues);
        }else{
            throw new IllegalArgumentException("The generator is unable to generate this template.Please recheck your input");
        }
    }

    /**
     * iterates through all the generators and gets the values generated by each one
     * @return returns true if all the generations were successful and false if otherwise
     */
    private boolean iterate() {
        // loop through all the subGenerators and call their generate method
        for (Map.Entry<Integer, ISubGenerator> entry : this.iSubGenerators.entrySet()) {
            Integer index = entry.getKey();
            ISubGenerator iSubGenerator = entry.getValue();

            //normal generators need past values , by default then the "input" property will have the same index
            //tools need an input from another generator
            String input = getInput(index);
            String value = iSubGenerator.generate(input);
            if (value == null) return false;
            int wantedLength =this.template.getPatternsMap().get(index).getLength();
            if(wantedLength!=0 && value.length() !=  wantedLength) return false;

            this.values.put(index, value);
        }
        return true;
    }

    /**
     * Gets the input for a specific generator
     * @param index index of the generator from which the input is needed
     * @return the input
     */
    private String getInput(Integer index) {
        Integer inputIndex = this.template.getPatternsMap().get(index).getInput();
        return this.values.get(inputIndex);
    }

    /**
     * Initialises the values map with starting values
     */
    private void initValuesMap() {
        for (Map.Entry<Integer, ISubGenerator> entry : this.iSubGenerators.entrySet()) {
            Integer index = entry.getKey();
            Integer inputIndex = this.template.getPatternsMap().get(index).getInput();

            if (index.equals(inputIndex)) {
                String start = this.template.getPatternsMap().get(index).getStartString();
                this.values.put(index, start);
            }
        }
    }

    /**
     * Format a given value by template's format string
     * * @return formatted value
     */
    public String format(List<String> results) {
        return this.template.getFormatter().format(results);
    }

}

